input {
  tcp {
    port => 5000
    codec => json_lines
  }
}

filter {
  ruby {
    code => 'event.set("[@metadata][telegram_enabled]", !ENV["TELEGRAM_BOT_TOKEN"].to_s.empty? && !ENV["TELEGRAM_CHAT_ID"].to_s.empty?)'
  }

  if ![timestamp] {
    mutate { add_field => { "received_at" => "%{@timestamp}" } }
  }

  if [event_type] == "ANOMALY" {
    mutate {
      convert => {
        "anomaly_deviation" => "float"
        "anomaly_actual" => "float"
        "anomaly_predicted" => "float"
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "energy-server-logs-%{+YYYY.MM.dd}"
  }

  if "DB_STRESS" in [message] and [@metadata][telegram_enabled] {
      http {
        url => "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
        http_method => "post"
        content_type => "application/json"
        format => "message"
        message => '{"chat_id": "${TELEGRAM_CHAT_ID}", "parse_mode": "Markdown", "text": "ğŸš¨ *ENERGY SYSTEM ALERT* ğŸš¨\n\nâš ï¸ *Status:* Database Unreachable\nğŸ”¢ *Failures:* %{failure_count}\nğŸ“‰ *Action:* Data rerouted to RabbitMQ (Fallback Enabled)\n\nğŸ“ _Check Kibana/Logs for the specific exception stack_"}'
      }
    }

  if "ANOMALY_ALERT" in [message] and [@metadata][telegram_enabled] {
    http {
      url => "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
      http_method => "post"
      content_type => "application/json"
      format => "message"
      message => '{"chat_id": "${TELEGRAM_CHAT_ID}", "parse_mode": "Markdown", "text": "ğŸ¤– *AI ANOMALY DETECTED* ğŸ¤–\n\nğŸ“Š *Deviation:* %{anomaly_deviation}%\nğŸ”® *Predicted:* %{anomaly_predicted} kW\nâš¡ *Actual:* %{anomaly_actual} kW\n\n_The AI Model has detected an unusual consumption pattern._"}'
    }
  }

  # --- DEBUG CONSOLE ---
  stdout { codec => rubydebug }
}